[{"id":0,"href":"/my-doc-website/docs/welcome/","title":"Welcome","section":"Docs","content":" Welcome to My Linux Learning Hub # Welcome to my little corner of the web, built using Hugo with the Lotus Docs theme. But while this site runs on Hugo, it‚Äôs not just about Hugo‚Äîit‚Äôs about Linux, open-source tools, and the journey of learning. If you‚Äôre new to Linux, you‚Äôre in the right place.\nHow This Site Started # Like many beginners, I found Linux exciting but sometimes overwhelming. I‚Äôd tinker, break things, fix them (or try to), and take notes along the way. I started using Hugo, a powerful static site generator, to document my learning process, but my first attempt was frustrating. I picked a theme that was too complex for a beginner, and I quickly hit a wall.\nThen, I heard about Lotus Docs on a podcast called LinuxCast. One of the hosts, Drew, mentioned it as a terrific documentation-based Hugo theme. That was the nudge I needed. With a little help from my AI assistant‚Äîwho I call Chad‚ÄîI switched themes, started uploading my notes, and suddenly, everything clicked.\nWhy This Site Exists # This site is my way of organizing and sharing what I learn about Linux, from setting up servers to troubleshooting issues and finding the best open-source tools. If you‚Äôre on your own Linux journey, I hope these articles help you, too.\nI‚Äôve also discovered a handy workflow: I take notes during my learning sessions, often with Chad‚Äôs help, summarize them, and convert them into Markdown files for easy publishing. It‚Äôs a simple but effective way to build a personal knowledge base‚Äîand now, I‚Äôm sharing it with you.\nWhat You\u0026rsquo;ll Find Here # While this site is built with Hugo and Lotus Docs, the real focus is Linux. Expect to find:\nStep-by-step guides for Linux beginners Tips and troubleshooting for common issues Markdown workflows for note-taking and documentation Explorations of open-source software that make Linux even better This isn‚Äôt just a blog‚Äîit‚Äôs a growing documentation hub shaped by real-world learning and experience.\nSo, whether you‚Äôre setting up your first Linux server, tweaking your desktop environment, or trying to understand Markdown, I hope you find something useful here.\nWelcome aboard, and happy learning!\n"},{"id":1,"href":"/my-doc-website/docs/add-bash-completion-atuin-bash-extras-new-vms/","title":"Build a Better Bash with Atuin","section":"Docs","content":" Step-by-Step Plan for Setting Up Bash Completion and Atuin in New VMs # This guide will ensure that every new Ubuntu Server VM you set up has bash completion for tab completion and Atuin for enhanced shell history.\nStep 1: Update the System # Before installing anything, update and upgrade all packages.\nbash\nenter\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y\nStep 2: Install Required Tools # Since Ubuntu Server doesn‚Äôt include some essential tools by default, install the following:\nbash\nenter\nsudo apt install -y curl wget git unzip apt-transport-https ca-certificates lsb-release\nThese tools are required for downloading and installing software, including Atuin.\nStep 3: Install Bash Completion # Bash completion allows for easier command entry via tab completion.\nCheck if bash-completion is installed:\nbash\nenter\ndpkg -l | grep bash-completion\nIf installed, move to Step 4. If not installed, install it:\nbash\nenter\nsudo apt install -y bash-completion\nEnsure bash-completion is enabled by verifying that this block exists in ~/.bashrc:\nbash\nenter\nif ! shopt -oq posix; then\nif [ -f /usr/share/bash-completion/bash_completion ]; then\n. /usr/share/bash-completion/bash_completion\nelif [ -f /etc/bash_completion ]; then\n. /etc/bash_completion\nfi\nfi\nIf missing, add it to ~/.bashrc:\nbash\nenter\necho 'if ! shopt -oq posix; then\nif [ -f /usr/share/bash-completion/bash_completion ]; then\n. /usr/share/bash-completion/bash_completion\nelif [ -f /etc/bash_completion ]; then\n. /etc/bash_completion\nfi\nfi' \u0026gt;\u0026gt; ~/.bashrc\nApply the changes:\nbash\nenter\nsource ~/.bashrc\nStep 4: Install Atuin # Atuin enhances shell history with powerful search and synchronization.\nDownload and install Atuin using the official script:\nbash\nenter\ncurl --proto '=https' --tlsv1.2 -LsSf https://setup.atuin.sh | sh\nEnsure Atuin is added to your shell‚Äôs PATH (so it works in all sessions):\nbash\nenter\nsource $HOME/.atuin/bin/env\nRestart your shell to finalize the setup:\nbash\nenter\nexec \u0026quot;$SHELL\u0026quot;\nVerify the installation:\nbash\nenter\natuin --version\nIf you see a version number, Atuin is correctly installed. Step 5: Enable Atuin in Every SSH Session # To make sure Atuin is automatically loaded in every session:\nbash\nenter\necho 'source $HOME/.atuin/bin/env' \u0026gt;\u0026gt; ~/.bashrc\nApply the changes:\nbash\nenter\nsource ~/.bashrc\nStep 6: Test Everything # Test Bash Completion # Start typing a command, e.g.:\nbash\nenter\nsudo apt \u0026lt;\u0026lt;\u0026lt; add space also for more options\nPress Tab twice. If autocompletion works, you should see options like install, update, etc. Test Atuin # Run:\nbash\nenter\natuin search apt\nThis should return previous commands containing \u0026ldquo;apt\u0026rdquo;. Try using Atuin autocomplete: Start typing a previous command and press Ctrl + R to see enhanced history suggestions. Step 7: Repeat for Every New VM # Now, whenever you create a new VM, just follow this exact guide to set up bash completion and Atuin consistently across all machines.\nSummary of Commands # For reference, here‚Äôs the full list of commands to run in sequence:\nbash\nenter\n# Step 1: Update system\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y\n# Step 2: Install required tools\nsudo apt install -y curl wget git unzip apt-transport-https ca-certificates lsb-release\n# Step 3: Install bash-completion (if needed)\nsudo apt install -y bash-completion\necho 'if ! shopt -oq posix; then\nif [ -f /usr/share/bash-completion/bash_completion ]; then\n. /usr/share/bash-completion/bash_completion\nelif [ -f /etc/bash_completion ]; then\n. /etc/bash_completion\nfi\nfi' \u0026gt;\u0026gt; ~/.bashrc\nsource ~/.bashrc\n# Step 4: Install Atuin\ncurl --proto '=https' --tlsv1.2 -LsSf https://setup.atuin.sh | sh\nsource $HOME/.atuin/bin/env\nexec \u0026quot;$SHELL\u0026quot;\n# Step 5: Make Atuin work in all future SSH sessions\necho 'source $HOME/.atuin/bin/env' \u0026gt;\u0026gt; ~/.bashrc\nsource ~/.bashrc\n# Step 6: Verify everything\natuin --version\natuin search apt # Test history search\nThis plan is now concise, correct, and repeatable for every new VM you set up. üöÄ Let me know if you need any refinements!\nThis setup primarily applies to Bash (the default shell for Ubuntu Server) and Zsh. However, Atuin also supports Fish, but requires a different configuration step.\nShell Compatibility: # Shell Bash Completion Atuin Support Configuration Needed? Bash (Default) ‚úÖ Yes ‚úÖ Yes No extra config needed (already covered in the guide) Zsh ‚ùå No (Zsh has its own completion system) ‚úÖ Yes Needs manual Atuin configuration Fish ‚ùå No ‚úÖ Yes Uses a different config file (env.fish) If Using Zsh # For Zsh users, Atuin still works, but Bash completion isn\u0026rsquo;t needed. You must add Atuin‚Äôs environment config manually:\nInstall Zsh (if not already installed)\nbash\nenter\nsudo apt install -y zsh\nAdd Atuin to your Zsh configuration\nbash\nenter\necho 'source $HOME/.atuin/bin/env' \u0026gt;\u0026gt; ~/.zshrc\nApply the changes\nbash\nenter\nsource ~/.zshrc\nIf Using Fish # Fish doesn‚Äôt use .bashrc or .zshrc, so Atuin needs a different approach:\nAdd Atuin‚Äôs Fish configuration\nbash\nenter\nsource $HOME/.atuin/bin/env.fish\nMake it persistent\nbash\nenter\necho 'source $HOME/.atuin/bin/env.fish' \u0026gt;\u0026gt; ~/.config/fish/config.fish\nRestart Fish\nbash\nenter\nexec fish\nTL;DR # Bash ‚Üí Works as is (guide is fine). Zsh ‚Üí Needs source $HOME/.atuin/bin/env in ~/.zshrc. Fish ‚Üí Needs source $HOME/.atuin/bin/env.fish in ~/.config/fish/config.fish. Would you like help setting up Zsh or Fish instead of Bash? üöÄ\nBUT WAIT THERE IS MORE\nYou said:\nI have installed bash-completion and atuin on my proxmox, a Debian-based server. Can I add some basic upgrades to the base bash prompt that will be useful? I don\u0026rsquo;t want to install Fish on all my servers since Bash is supported out of the box in all of them.\nChatGPT said: # Great call sticking with Bash‚Äîit keeps things consistent across all your servers without needing extra dependencies like Fish. Here are some practical Bash prompt upgrades that enhance usability, improve readability, and make working in the terminal more efficient.\n1Ô∏è‚É£ Add Git Status to Your Prompt (If You Use Git) # If you work with Git repositories, showing the branch and status in your prompt is helpful. Add this to ~/.bashrc:\nbash\nenter\nparse_git_branch() {\ngit branch 2\u0026gt;/dev/null | grep '*' | sed 's/* //'\n}\nexport PS1='\\[\\e[1;32m\\]\\u@\\h\\[\\e[0m\\]:\\[\\e[1;34m\\]\\w\\[\\e[1;33m\\] $(parse_git_branch)\\[\\e[0m\\]\\$ '\nWhat This Does: # ‚úÖ Shows username and hostname in green\n‚úÖ Shows the working directory in blue\n‚úÖ Displays the current Git branch in yellow (if inside a Git repo)\n2Ô∏è‚É£ Show Exit Code of Last Command (Only if it Fails) # Sometimes, you run a command, and it fails‚Äîthis makes it obvious by displaying the exit code in red.\nAdd this function to ~/.bashrc:\nbash\nenter\nshow_exit_code() {\nEXIT_CODE=$?\nif [ $EXIT_CODE -ne 0 ]; then\necho -e \u0026quot;\\e[1;31mExit Code: $EXIT_CODE\\e[0m\u0026quot;\nfi\n}\nexport PROMPT_COMMAND=\u0026quot;show_exit_code; $PROMPT_COMMAND\u0026quot;\nWhat This Does: # ‚úÖ If the last command fails, it will display:\nExit Code: 1 (or whatever the exit code is)\n‚úÖ If the last command succeeds, nothing changes\n3Ô∏è‚É£ Add Timestamps to Your History # Bash normally saves commands without timestamps. Enable timestamps so you can see when each command was run.\nAdd this to ~/.bashrc:\nbash\nenter\nexport HISTTIMEFORMAT=\u0026quot;%F %T \u0026quot;\nWhat This Does: # ‚úÖ history now shows timestamps like:\nyaml\nenter\n1 2024-02-14 12:30:45 sudo apt update\n2 2024-02-14 12:31:12 ls -la\n4Ô∏è‚É£ Make Your Prompt Show the Last Command Execution Time # Ever run a command and wonder how long it took? This adds execution time info to your prompt.\nAdd this to ~/.bashrc:\nbash\nenter\nexport PROMPT_COMMAND='LAST_CMD_TIME=$SECONDS; PREV_LAST_CMD_TIME=$LAST_CMD_TIME; $PROMPT_COMMAND'\nexport PS1='\\[\\e[1;32m\\]\\u@\\h\\[\\e[0m\\]:\\[\\e[1;34m\\]\\w\\[\\e[0m\\] (\\[\\e[1;35m\\]${PREV_LAST_CMD_TIME}s\\[\\e[0m\\])\\$ '\nWhat This Does: # ‚úÖ Shows execution time of the last command in purple\n‚úÖ If the last command took 5 seconds, prompt will look like:\nruby\nenter\nuser@server:~/folder (5s)$\n‚úÖ If the command was instant, the (0s) disappears\n5Ô∏è‚É£ Enable Persistent History Across Sessions # By default, Bash only saves history at the end of a session, meaning if multiple terminals are open, they don‚Äôt share history. Fix this:\nAdd this to ~/.bashrc:\nbash\nenter\nshopt -s histappend\nPROMPT_COMMAND=\u0026quot;history -a; history -c; history -r; $PROMPT_COMMAND\u0026quot;\nWhat This Does: # ‚úÖ Instantly saves each command you run to history\n‚úÖ History is shared across multiple terminals (so all sessions see the latest commands)\n‚úÖ Prevents history loss when multiple terminal windows are open\n6Ô∏è‚É£ Enable Better Navigation (Ctrl+Arrow for Word Jumps) # By default, Bash doesn‚Äôt let you jump word by word using Ctrl+‚Üê and Ctrl+‚Üí like in most modern shells.\nAdd this to ~/.inputrc (create the file if it doesn\u0026rsquo;t exist):\nbash\nenter\n\u0026quot;\\e[1;5D\u0026quot;: backward-word\n\u0026quot;\\e[1;5C\u0026quot;: forward-word\nWhat This Does: # ‚úÖ Ctrl+‚Üê jumps back one word\n‚úÖ Ctrl+‚Üí jumps forward one word\n‚úÖ Makes navigation faster when editing long commands\n7Ô∏è‚É£ Shorten Your Prompt on Long Paths # By default, if you\u0026rsquo;re deep inside a directory, your prompt gets very long. Fix this by shortening the path.\nAdd this function to ~/.bashrc:\nbash\nenter\nexport PS1='\\u@\\h:\\w$( [ ${#PWD} -gt 40 ] \u0026amp;\u0026amp; echo \u0026quot;‚Ä¶${PWD: -20}\u0026quot;)\\$ '\nWhat This Does: # ‚úÖ Shortens the displayed path if it\u0026rsquo;s longer than 40 characters\n‚úÖ Example:\nruby\nenter\nuser@server:/home/user/projects/super-long-directory-name$ # Normal\nuser@server:‚Ä¶per-long-directory-name$ # Shortened\n8Ô∏è‚É£ Improve \u0026ldquo;cd\u0026rdquo; Behavior (Auto Push to Stack) # Make cd - work like a stack so you can jump back to previous directories easily.\nAdd this to ~/.bashrc:\nbash\nenter\ncd() {\nbuiltin cd \u0026quot;$@\u0026quot; || return\npwd \u0026gt; ~/.lastdir\n}\nalias -- -='cd \u0026quot;$(cat ~/.lastdir)\u0026quot;'\nWhat This Does: # ‚úÖ Every time you cd into a directory, it remembers the previous one\n‚úÖ Typing - jumps back to the last directory\n‚úÖ Example:\nbash\nenter\ncd /var/log\ncd /etc\n-\n# Now you're back in /var/log!\nFinal Steps: Apply the Changes # After making changes to ~/.bashrc, apply them with:\nbash\nenter\nsource ~/.bashrc\nIf you edited ~/.inputrc, apply changes with:\nbash\nenter\nbind -f ~/.inputrc\nüìå TL;DR - What These Enhancements Do # ‚úî Adds Git branch status to your prompt\n‚úî Shows exit codes for failed commands\n‚úî Saves timestamps in history\n‚úî Displays execution time for commands\n‚úî Keeps Bash history persistent across sessions\n‚úî Enables Ctrl+‚Üê / Ctrl+‚Üí word jumps\n‚úî Shortens long paths in the prompt\n‚úî Improves cd - navigation\nThese upgrades keep Bash lightweight but powerful, giving you some of Fish/Zsh\u0026rsquo;s best features without adding new dependencies.\nWould you like a specific feature customized further? üöÄ\nYou said: # this only keeps them current for the current session though right?\nChatGPT said: # You\u0026rsquo;re correct‚Äîif you add these changes to ~/.bashrc and just run source ~/.bashrc, they\u0026rsquo;ll only apply to the current session. However, once they are saved in ~/.bashrc, they persist across reboots and new SSH sessions automatically.\nTo ensure all changes always apply in every new terminal session, just do this once:\nMake sure everything is in ~/.bashrc\nIf you‚Äôve added the changes to ~/.bashrc, they will persist across all future SSH sessions and logins. You don‚Äôt need to manually source ~/.bashrc every time‚Äîyou just need to restart your shell or open a new terminal. For Immediate Effect in Current Session\nAfter editing ~/.bashrc, run:\nbash\nenter\nsource ~/.bashrc\nThis ensures the changes take effect immediately without needing to restart your shell. For Changes in All New Terminals or SSH Sessions\nThe next time you open a new terminal or SSH into the server, these settings will already be applied. You do not need to run anything again. Exceptions Where It Won‚Äôt Persist # If you edit only ~/.bash_profile instead of ~/.bashrc ~/.bash_profile runs only for login shells (like when logging in via SSH), but not for interactive shells (like opening a new terminal from an already logged-in session). Solution: Always put changes in ~/.bashrc for consistency. If you use su - instead of su su - loads a clean environment without user-specific configs. Solution: If switching users, explicitly source the file:\nbash\nenter\nsource ~/.bashrc\nIf your shell is not Bash If you‚Äôre using Zsh or Fish, ~/.bashrc won‚Äôt be loaded. Solution: Modify ~/.zshrc or ~/.config/fish/config.fish instead. To Apply Changes System-Wide (All Users) # If you want these prompt improvements for all users on the system, instead of just your account:\nEdit the global Bash configuration:\nbash\nenter\nsudo nano /etc/bash.bashrc\nAdd the same prompt modifications inside that file. Save and exit (Ctrl+X, then Y, then Enter). Apply changes immediately:\nbash\nenter\nsource /etc/bash.bashrc\nTL;DR # If added to ~/.bashrc, changes persist for your user across reboots and SSH sessions. If added to /etc/bash.bashrc, changes persist system-wide for all users. After editing, source ~/.bashrc makes changes apply immediately without restarting. Would you like help setting this up across multiple servers at once? üöÄ\nYou said: # how do I add the first one for example to ~/.bashrc and make it persistent?\nChatGPT said: # Great question! Let\u0026rsquo;s go step by step to add the Git branch status to your Bash prompt and make sure it persists across all future sessions.\nStep 1: Open ~/.bashrc for Editing # Run the following command to open your Bash configuration file in nano:\nbash\nenter\nnano ~/.bashrc\nStep 2: Add the Git Branch Function to Your Prompt # Scroll to the bottom of the file (using the arrow keys) and add this code:\nbash\nenter\n# Function to show the current Git branch\nparse_git_branch() {\ngit branch 2\u0026gt;/dev/null | grep '*' | sed 's/* //'\n}\n# Custom Bash Prompt with Git Branch\nexport PS1='\\[\\e[1;32m\\]\\u@\\h\\[\\e[0m\\]:\\[\\e[1;34m\\]\\w\\[\\e[1;33m\\] $(parse_git_branch)\\[\\e[0m\\]\\$ '\nStep 3: Save the File and Exit # Press CTRL + X to exit nano. Press Y to confirm saving changes. Press Enter to save and exit. Step 4: Apply the Changes Immediately # Run this command to reload the ~/.bashrc file without logging out:\nbash\nenter\nsource ~/.bashrc\nStep 5: Verify That It Works # Navigate to a directory that contains a Git repository:\nbash\nenter\ncd /path/to/git-repo\nCheck if the Git branch name appears in your prompt. If you\u0026rsquo;re inside a Git repo, it should now display:\nruby\nenter\nuser@server:/path/to/repo main$\nWhere main (or master) is the branch name. Step 6: Make Sure It Works in New SSH Sessions # Close your terminal and open a new one. SSH back into your server and check if the Git branch appears. If it does, your custom Bash prompt persists across all sessions! Bonus: Make It System-Wide (All Users) # If you want all users on your server to have this Git-enabled prompt, edit the global Bash config:\nbash\nenter\nsudo nano /etc/bash.bashrc\nThen, add the same function and PS1 line to the bottom of the file. Save and exit, then apply:\nbash\nsource /etc/bash.bashrc\nNow, every user on the system will have this prompt!\nYou\u0026rsquo;re Done! üéâ # This Git-enhanced Bash prompt will now persist across reboots and all SSH sessions.\nWould you like to tweak it further? Maybe add colors or execution time? üöÄ\n"},{"id":2,"href":"/my-doc-website/docs/docker-compose-watchtower-install/","title":"How to Auto Update Docker Apps With Watchtower","section":"Docs","content":" Step-by-Step Guide to Install Docker, Docker Compose, Watchtower on Ubuntu Server 24.04 # This guide ensures you install the latest Docker Engine and Docker Compose on Ubuntu Server 24.04 (Noble), using the official Docker repositories. As a bonus, it also includes directions to install Watchtower which will help keep your docker contained applications updated automatically and send you a notification via ntfy if updates occur\nStep 1: Update the System # Ensure your system is up to date before installing any packages:\nbash\nCopyEdit\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y\nStep 2: Install Required Dependencies # Install required system packages:\nbash\nCopyEdit\nsudo apt install -y ca-certificates curl gnupg\nStep 3: Add Docker‚Äôs Official GPG Key # Docker packages are signed, so we need to add the official GPG key:\nbash\nCopyEdit\nsudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo tee /etc/apt/keyrings/docker.asc \u0026gt; /dev/null\nsudo chmod a+r /etc/apt/keyrings/docker.asc\nStep 4: Add the Docker Repository (For Ubuntu 24.04 Noble) # Now, add the Docker stable repository to your system:\nbash\nCopyEdit\necho \u0026quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu noble stable\u0026quot; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\nThen update the package index again:\nbash\nCopyEdit\nsudo apt update\nStep 5: Install Docker Engine and Docker Compose Plugin # Now, install the latest versions of Docker and the Compose plugin:\nbash\nCopyEdit\nsudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\nStep 6: Enable and Start the Docker Service # Ensure that Docker starts on boot and is currently running:\nbash\nCopyEdit\nsudo systemctl enable --now docker\nCheck the service status:\nbash\nCopyEdit\nsudo systemctl status docker\nStep 7: Verify Installation # Check that Docker is installed correctly:\nbash\nCopyEdit\ndocker --version\nVerify the Docker Compose plugin:\nbash\nCopyEdit\ndocker compose version\nRun a test container to ensure everything works:\nbash\nCopyEdit\ndocker run hello-world\nStep 8: Add Your User to the Docker Group (Optional, for Non-root Access) # By default, you need sudo to run Docker commands. To run Docker as a regular user, add yourself to the docker group:\nbash\nCopyEdit\nsudo usermod -aG docker $USER\nApply the group change immediately:\nbash\nCopyEdit\nnewgrp docker\nNow test running Docker without sudo:\nbash\nCopyEdit\ndocker run hello-world\nStep 9: Keeping Docker and Compose Updated # Since Docker releases frequent updates, update your system regularly:\nbash\nCopyEdit\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y\nFor a more targeted update, check if a new Docker version is available:\nbash\nCopyEdit\napt list --upgradable | grep docker\nThen update Docker only:\nbash\nCopyEdit\nsudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\nFinal Verification # After completing the steps, verify the installation one last time:\nbash\nCopyEdit\ndocker --version\ndocker compose version\ndocker run hello-world\nAt this point, you have the latest Docker and Docker Compose installed on Ubuntu 24.04, fully functional and ready to use.\nYou said: # Add one final step. Install Watchtower to keep the containers updated. Or should that be after freshRSS in this case, is installed?\nChatGPT said: # Final Step: Install Watchtower for Automatic Container Updates # Watchtower automatically updates your running Docker containers when new versions are available. However, you should install Watchtower after deploying key applications like FreshRSS to ensure everything is set up correctly before automating updates.\nStep 11: Install Watchtower # Once FreshRSS (or any other critical containerized applications) is running, install Watchtower with:\nbash\nCopyEdit\ndocker run -d \\\n--name watchtower \\\n--restart unless-stopped \\\n-v /var/run/docker.sock:/var/run/docker.sock \\\ncontainrrr/watchtower\n(Optional) Enable Notifications # To get update notifications, add environment variables for your preferred service (e.g., Slack, Discord, email):\nbash\nCopyEdit\ndocker run -d \\\n--name watchtower \\\n--restart unless-stopped \\\n-v /var/run/docker.sock:/var/run/docker.sock \\\n-e WATCHTOWER_NOTIFICATIONS=email \\\n-e WATCHTOWER_NOTIFICATION_EMAIL_FROM=\u0026quot;your-email@example.com\u0026quot; \\\n-e WATCHTOWER_NOTIFICATION_EMAIL_TO=\u0026quot;your-email@example.com\u0026quot; \\\ncontainrrr/watchtower\nVerify Watchtower is Running # Check logs to confirm Watchtower is monitoring containers:\nbash\nCopyEdit\ndocker logs -f watchtower\nShould You Install Watchtower Before or After FreshRSS? # ‚úÖ After FreshRSS installation is ideal. That way, you ensure FreshRSS is set up properly before enabling automatic updates, which could introduce changes unexpectedly.\nWould you like a FreshRSS installation guide next?\nYou said: # With built in ntfy.sh running when watchtower runs\nChatGPT said: # Final Step: Install Watchtower with Built-in Ntfy.sh Notifications # Watchtower will automatically update Docker containers and send notifications via Ntfy.sh whenever it updates a container.\nStep 11: Install Watchtower with Ntfy.sh Notifications # Run Watchtower with Ntfy.sh\nReplace \u0026lt;your-ntfy-topic\u0026gt; with your chosen topic (e.g., freshrss-updates):\nbash\nCopyEdit\ndocker run -d \\\n--name watchtower \\\n--restart unless-stopped \\\n-v /var/run/docker.sock:/var/run/docker.sock \\\n-e WATCHTOWER_NOTIFICATIONS=ntfy \\\n-e WATCHTOWER_NOTIFICATION_URL=\u0026quot;https://ntfy.sh/\u0026lt;your-ntfy-topic\u0026gt;\u0026quot; \\\ncontainrrr/watchtower\nVerify Watchtower is Running\nCheck logs to confirm Watchtower is monitoring containers and sending notifications:\nbash\nCopyEdit\ndocker logs -f watchtower\nTest Ntfy.sh Notifications\nOpen your Ntfy.sh topic URL (https://ntfy.sh/\u0026lt;your-ntfy-topic\u0026gt;) in a browser or use the mobile app to verify Watchtower messages. Should You Install Watchtower Before or After FreshRSS? # ‚úÖ Install Watchtower after FreshRSS to avoid automatic updates during the initial setup.\nWould you like a FreshRSS installation guide next?\n"},{"id":3,"href":"/my-doc-website/docs/hugo-website-with-actions-and-pages/","title":"How to Build Hugo Website","section":"Docs","content":" A step-by-step guide to deploying a static Hugo site with full CI/CD using GitHub Actions and Pages # Prerequisites # A GitHub account A Linux machine (tested on Xubuntu Minimal) Basic knowledge of the command line Step 1: Remove Any Previous Setup # sh\nCopyEdit\nrm -rf ~/my-doc-website\nThen, delete any existing GitHub repository for the project.\nStep 2: Create a New GitHub Repository # Go to GitHub, create a new repository named my-doc-website.\nStep 3: Clone the Repository to Your Local Machine # sh\nCopyEdit\ncd ~ git clone git@github.com:calabiyau19/my-doc-website.git cd my-doc-website\nStep 4: Install Necessary Software # sh\nCopyEdit\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y sudo apt install git -y git --version\nStep 5: Install Hugo # sh\nCopyEdit\nsudo dpkg -i hugo_extended_0.143.1_linux-amd64.deb hugo version\nStep 6: Add the Anatole Theme # sh\nCopyEdit\ngit submodule add https://github.com/lxndrblz/anatole.git themes/anatole ls themes\nStep 7: Configure Hugo (hugo.toml) # sh\nCopyEdit\nnano hugo.toml\nReplace contents with:\ntoml\nCopyEdit\nbaseURL = \u0026quot;https://calabiyau19.github.io/my-doc-website/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My Doc Website\u0026quot; theme = \u0026quot;anatole\u0026quot;\nStep 8: Start Hugo Locally # sh\nCopyEdit\nhugo server -D\nStep 9: Add a Profile Picture # sh\nCopyEdit\nmkdir -p static/images cp ~/Downloads/profile.jpg static/images/profile.jpg\nStep 10: Add a First Blog Post # sh\nCopyEdit\nhugo new blog/my-first-post.md nano content/blog/my-first-post.md\nStep 11: Commit and Push the Site to GitHub # sh\nCopyEdit\ngit add . git commit -m \u0026quot;Initial Hugo setup\u0026quot; git push origin main\nStep 12: Set Up GitHub Pages # Go to GitHub repository ‚Üí Settings ‚Üí Pages ‚Üí Set branch to main ‚Üí Save.\nStep 13: Set Up GitHub Actions for Deployment # sh\nCopyEdit\nmkdir -p .github/workflows nano .github/workflows/deploy.yml\nStep 14: Commit and Push GitHub Actions Workflow # sh\nCopyEdit\ngit add .github/workflows/deploy.yml git commit -m \u0026quot;Add GitHub Actions workflow\u0026quot; git push origin main\nStep 15: Enable GitHub Actions Write Permissions # Go to GitHub repository ‚Üí Settings ‚Üí Actions ‚Üí Set permissions.\nStep 16: Manually Create the gh-pages Branch # sh\nCopyEdit\ngit checkout --orphan gh-pages git rm -rf . git commit --allow-empty -m \u0026quot;Initialize gh-pages branch\u0026quot; git push origin gh-pages git checkout main\nStep 17: Trigger Deployment Again # sh\nCopyEdit\nnano hugo.toml # Add a small change\ngit add hugo.toml git commit -m \u0026quot;Trigger new deployment\u0026quot; git push origin main\nStep 18: Verify Deployment # Go to GitHub Actions tab ‚Üí Ensure deployment is successful.\nVisit: https://calabiyau19.github.io/my-doc-website/\nüéâ Done! Your Hugo site is fully deployed with CI/CD\n"}]